# Final Project - CMPSC 441 Artificial Intelligence SP2023  - Max Piazza (mcp5552)

## 1. Abstract

This project is a computer game programmed in python using the Pygame library. The game takes place on a map with varying elevation and 10 cities on it. Cities have traversable connections between them, but not every city is connected to every other city. The player must navigate from the start city ("Loudwater") to the end city ("Evereska") without dying or running out of money. Traveling from one city to another costs money. When selecting a route, the player is told the route cost and can choose to accept or decline to travel on that route. The amount of money it takes to travel from a city to another depends on elevation of the route; these costs are calculated when the map is generated. As the player moves across a route from one city to another, they may encounter one or more bandits. Encountering a bandit begins a turn-style combat, wherein the player must select a weapon to use for the turn (Sword, Arrow, or Fire) and is shown the outcome of the choice. If the player loses the encounter, they die and the game is over, otherwise they obtain some money that they can use for traveling. If the player runs out of money before reaching the destination, they lose and the game is over. If they Evereska, they win.

## List of AI Components

- Journal entries (and city names) are generated by openAI GPT-3. 
- Placement of cities on game map is achieved through genetic algorithm solution breeding.
- Bandits are computer-controller players who select weapons for turns of combat according to a software method. 

## Problems Solved with AI

- **Journaling:** to the game's State class have been added a list of strings called **journal** and a Boolean called **journal_entry_produced**. Whenever the player arrives at a new city (and the **travelling** Boolean in the State class is set back to False after having been set to True), **journal_entry_produced** (initially True) is set to False  — this triggers the entering of an if statement in the game main while loop wherein: the journal is appended with a new entry by calling getResponse() from the openai library, and **journal_entry_produced** is set back to True. The openai getResponse() method takes in a as a string a prompt for the large language model to respond to, and returns the response of the model as a string. A variable called **encounter_cnt** has been added to the game's state class; it is used to specify the number of bandit encounters in the GPT prompt so that the journal entry can mention the number of bandits encountered. There are three possible prompts depending on the encounter count: one for 0, 1, and more than 1 encounters. The game state class also has a variable called new_money which is incremented by the amount of money a bandit drops when they are defeated. This value is reset to 0 when the player has made it to their destination city. This variable is used so the journal entry produced after traveling down a route can mention how much money was collected from defeating bandits while traveling down that route. In addition to journaling, the names of all of the cities except for the start and end cities are also generated by GPT getReponse() calls. (Note: the GPT journaling feature requires an openai API key,  a key was included with the code in development but has been omitted from the code on the github repository). 
- **City Placement:** Cities need to be placed on the map so that they randomly situated, but not placed at unrealistically high or low elevations. Using the pygad library, city placement is handled by a genetic algorithm using a few methods. The game_fitness() method is used as a fitness function; it looks at a particular city distribution given an elevation map and returns a fitness score which will be high if the cities are all appropriately placed and low if any of the cities are inappropriately placed. The setup_GA() method creates a pygad.GA genetic algorithm object; it requires a fitness function (for which game_fitness() with the appropriate cities, elevation, and size parameters are used), a city number, and a map size tuple. It returns the fitness function and the genetic algorithm instance. Once the instance is created, the random initial population is prepared in the initial_population attribute. Then, the pygad run() method is called on the GA instance, causing a solution to be evolved through a number of generations. This works by repeatedly creating a number of random variations on the previous ancestor, evaluating them for fitness, and designating as the parent of future generations the offspring that is most fit according to the fitness function. The best solution after a number of generations (specified in setup_GA() to be 100) is saved.
- **Bandits:** The game includes combat between the player and bandits; an AI is needed to control the decision making of the bandits. Combat is essentially a mini-game wherein two agents take turns making decisions about which weapon they will select for the turn; the outcome of the turn depends completely on the weapon selection à la Rock-Paper-Scissors. The PyGameComputerCombatPlayer class specifies the weapon selecting strategy that the computer-controlled agent uses for selecting weapons. The algorithm the AI uses as it input the health of the player the AI controls (the bandit); the output of the algorithm is the choice the AI player makes. The strategy implemented is simple — the AI always selects the same choice depending on the remaining health of the bandit. 

## Other Features Implemented

- **Randomized map elevations:** From the perlin_noise library, the PerlinNoise method is imported and is used to generate a map with random elevation values. 
- **Money:** The player's money has been added as a variable to the state class for the game.  Money in the game is measured in £. The player's money value is printed in the upper-left hand corner of the game screen when viewing the map. The player's money amount is continuously checked — running out of money causes the game to end. Money is initialized to a random value between £170 and £240. The player's current money is printed whenever they arrive at a new city. When bandits are defeated, they drop a random amount of money between £2.50 and £25.00.
- **Restriction of travel to cities with routes to them:** While the main loop of the game is running, the game continuously reads in character inputs; inputs of 0-9 are interpreted as choices for the next city to travel to and are processed. The route that corresponds to the start city/end city tuple implied by the choice the player makes when selecting a destination is looked for in the routes list; if it is not there the game will print that there is no route and will not allow the player to travel to that destination city. 
- **Route Costs:** The bresenham method from the bresenham library is used to find all the cells along the route lines between cities. For all these cells, the elevation is checked and the sum of the elevations is used as the basis for the cost of the route (the values are also rounded and the max() method is used to make 0 the lowest possible cost). If a player inputs a number corresponding to a destination city which is found to correspond to a valid route in the route list upon checking, the player will start moving to the destination city; the game will deduct the cost of the route from the player's money amount once they have gotten to the end of the route. 
- **Requiring players to accept routes:** Since route costs are not drawn onto the map, the game tells players the cost of a route by printing a message that gives the cost when a player attempts to select a destination city that would cause them to travel along the ro. This is done because in some cases a route costs more money to travel down than a player has.
- **Game Over:** If the player's money hits 0 or the player loses combat, they will lose the game; if a player makes it to Evereska they will win the game. 
- **Music:** Two songs have been added to the game: a main theme which plays when viewing the main map screen, and a combat song which plays when a player is in combat. 
